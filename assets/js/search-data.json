{
  
    
        "post0": {
            "title": "Constructing a complex dictionary of base and derived class using the same code",
            "content": "Okay, really complex title aside, I‚Äôll try to explain the problem I had and the interesting way I found to solve it. This may not be the best or the most optimized way, but I really liked this solution and would like to share it. . Also, although I do prefer Python, this post is in C#, since that was the language I encountered this problem in. . So here is the problem. Say we have two C# Classes . public class BaseClass { public string SomeProperties { get; set; } } public class DerivedClass : BaseClass { public string SomeOtherProperties { get; set; } } . I wanted to construct a Dictionary of these classes like Dictionary&lt;string, BaseClass&gt; and Dictionary&lt;string, DerivedClass&gt; at two very different places. The construction of each dictionary element was not that trivial due to the inherent complexity of filling the properties for both the classes. Here is an example of how one of the dictionaries was being created: . // For the base class var map = new Dictionary&lt;string, BaseClass&gt;(); foreach(var someProperty in someList) { var baseElement = new BaseClass(someProperty); map[someProperty] = baseElement; } foreach(var dependency in dependencyList) { map[dependency.To] = map[dependency.From] } // For the derived class var map = new Dictionary&lt;string, DerivedClass&gt;(); foreach(var someProperty in someList) { // someOtherProperty comes from somewhere else var derivedElement = new DerivedClass(someProperty, someOtherProperty); map[someProperty] = derivedElement; } foreach(var dependency in dependencyList) { map[dependency.To] = map[dependency.From] } . As you can see, there is a lot of logic repeating since the properties that were created for the base class were also created for the derived class, but when we create the DerivedClass object, new properties were also to be added to those object. Both the objects differ in how they are constructed but the way the map is created is similar. I wanted a way to reuse these for loops instead of writing them for both BaseClass and DerivedClass and other classes that might inherit from BaseClass later. . My basic idea was to use a Template method like this. . public Dictionary&lt;string, &lt;T&gt;&gt; CreateDictionary(parameters) { while(someConditionOnParameters) { if(T is BaseClass) { // Base class object creation code } else if(T is DerivedClass) { // Derived class object creation code } // repeated dictionary creation code } } . The other problem that I encounter here in was the arguments to this method. When we create the BaseClass object, I require fewer properties but when I created DerivedClass object, I require more properties and hence the number and type of arguments couldn‚Äôt be fixed. Of course, I can set/pass them as null and ignore when not needed, but that didn‚Äôt feel like a tidy solution to me. Plus later on, when we derive a new class from BaseClass, again the signature of method changes which might break a few things here and there. . That‚Äôs when I was suggested the interesting solution to this problem, the one I am going to share now. We keep one function that creates this dictionary but rather than passing the parameters to create the objects, we pass a function that creates those objects for us. For example when we want to create the BaseClass dictionary, we can pass a function that creates the base class object and so on. This way this method can be extensible for any classes that derive from future as well. Here is a dummy code to show how that method might look like . public Dictionary&lt;string, BaseClass&gt; CreateDictionary(DataObject requiredData, Func&lt;Data, BaseClass&gt; objectCreator) { var map = new Dictionary&lt;string, BaseClass&gt;(); foreach(Data propertyValues in requiredData.data) { var element = objectCreator(Data); } foreach(var dependency in requiredData.dependencies) { map[dependency.To] = dependency.From; } } . Now when I want to create the base class dictionary, I can call it like: . var map = CreateDictionary(requiredData, x =&gt; { return new BaseClass(x.somePropertyValue); }); . Or if I want the derived class dictionary, like this: . var map = CreateDictionary(requiredData, x =&gt; { return new DerivedClass(x.SomePropertyValue, someOtherPropertyValue); }); . I really loved this solution, its nifty and useful and this didnt come to my mind easily. . Closing Thoughts . I know this is a really specific and weird problem to encounter, and some constraints of why this solution was used over other ways are not clear from the vague names and class designs (and possibly incomplete details) I provided. However, I really found the solution interesting and felt like sharing it. . You can always share your thoughts on this by @‚Äôing me on Twitter or LinkedIn (links are available in my author bio) or even this blog‚Äôs GitHub repo. .",
            "url": "https://mitesh1612.github.io/blog/c%23/dictionaries/objects/2020/08/13/constructing-objects.html",
            "relUrl": "/c%23/dictionaries/objects/2020/08/13/constructing-objects.html",
            "date": " ‚Ä¢ Aug 13, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Welcome to this blog",
            "content": "Welcome to this blog . Hey everyone, welcome to my blog. I finally took the leap and set up my blog, and after a lot of thinking, I finally decided to create a blog. . Why a blog? Well among a lot of other reasons, like not forgetting what I learn from time to time, and to keep track of my journey as a Software Development Engineer. The other huge reason is that I love to learn new things, research the ones I find interesting, and I plan to document and share my learnings via blog posts, which can be easily found and referred to later as well. I‚Äôll try to share things I learn about Software Development, my interests in Data Science and all the other random things I encounter. Hopefully, other people will also find these posts helpful, relevant or interesting. You can always share your views on my GitHub repo here (until I figure out adding comment sections to a static GitHub site üòâ) . Thanks for visiting this blog! . About Me . I‚Äôm Mitesh Shah, and I live in Hyderabad. I started my journey as a Software Engineer at Microsoft (where I currently work). I have a lot of interest in Data Science and Machine Learning and I love reading books or playing some games in my relaxing time. . Technical Details for this Blog . This blog is possible due to Gatsby JS with the wonderful theme Novela created by the Narative Team. Right now this site is hosted on GitHub pages using a CI from GitHub Actions . Update : 24-12-2020 . Since then, I have moved this blog to Fastpages. The links in this post are updated now. .",
            "url": "https://mitesh1612.github.io/blog/introduction/2020/08/12/welcome-to-this-blog.html",
            "relUrl": "/introduction/2020/08/12/welcome-to-this-blog.html",
            "date": " ‚Ä¢ Aug 12, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Hey there. I am the writer and maintainer of this blog, Mitesh Shah. Right now I work as a Software Engineer in Microsoft and love to read up on various topics like Data Science, Machine Learning, Backend Development in my free time. Feel free to connect with my on my socials. .",
          "url": "https://mitesh1612.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ ‚Äúsitemap.xml‚Äù | absolute_url }} | .",
          "url": "https://mitesh1612.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}